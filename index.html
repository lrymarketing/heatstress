<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat & Weather Check</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Icons are now inline SVGs, no external scripts needed -->

    <style>
        /* Apply Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple spinning animation for loader */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white w-full max-w-md p-6 sm:p-8 rounded-2xl shadow-lg">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Weather & Safety</h1>
            <p class="text-gray-500 mt-1">Check your local conditions and heat risk.</p>
        </header>

        <main>
            <!-- Check Button -->
            <button id="checkButton" class="w-full bg-blue-600 text-white font-bold py-4 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-300 ease-in-out flex items-center justify-center space-x-2">
                <!-- Inlined "navigate-circle-outline" icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="text-2xl w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path>
                </svg>
                <span>Check My Location</span>
            </button>

            <!-- Loading Spinner (hidden by default) -->
            <div id="loader" class="hidden w-full bg-blue-600 text-white font-bold py-4 px-6 rounded-lg shadow-md flex items-center justify-center space-x-3">
                <div class="loader"></div>
                <span>Fetching Weather...</span>
            </div>

            <!-- Error Message Box (hidden by default) -->
            <div id="errorBox" class="hidden mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                <strong class="font-bold">Error:</strong>
                <span id="errorMessage" class="block sm:inline"></span>
            </div>

            <!-- Manual Location Input (hidden by default) -->
            <div id="manualInputBox" class="hidden mt-4 space-y-2">
                <label for="locationInput" class="block text-sm font-medium text-gray-700">Or enter location manually:</label>
                <div class="flex space-x-2">
                    <input type="text" id="locationInput" placeholder="e.g., 'Sydney' or '90210'" class="flex-grow block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    <button id="searchButton" class="px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400">
                        Search
                    </button>
                </div>
            </div>

            <!-- Results Section (hidden by default) -->
            <div id="results" class="hidden mt-8 space-y-6">
                
                <!-- Location -->
                <div>
                    <h2 class="text-center text-xl font-semibold text-gray-700" id="location"></h2>
                </div>

                <!-- Main Warning -->
                <div id="warningBox" class="p-6 rounded-2xl shadow-md text-center">
                    <h3 class="text-4xl font-bold" id="feelsLikeTemp"></h3>
                    <p class="text-2xl font-semibold mt-1" id="warningLevel"></p>
                    <p class="text-lg opacity-80" id="warningMessage"></p>
                </div>

                <!-- Other Details Grid -->
                <div class="grid grid-cols-2 gap-4 pt-4">
                    <!-- Actual Temp -->
                    <div class="bg-gray-50 p-4 rounded-lg text-center shadow-sm">
                        <p class="text-sm font-medium text-gray-500">Actual Temp</p>
                        <p class="text-3xl font-bold text-gray-800" id="actualTemp"></p>
                    </div>
                    <!-- Humidity -->
                    <div class="bg-gray-50 p-4 rounded-lg text-center shadow-sm">
                        <p class="text-sm font-medium text-gray-500">Humidity</p>
                        <p class="text-3xl font-bold text-gray-800" id="humidity"></p>
                    </div>
                    <!-- Wind -->
                    <div class="bg-gray-50 p-4 rounded-lg text-center shadow-sm">
                        <p class="text-sm font-medium text-gray-500">Wind</p>
                        <p class="text-3xl font-bold text-gray-800" id="wind"></p>
                    </div>
                    <!-- Chance of Rain -->
                    <div class="bg-gray-50 p-4 rounded-lg text-center shadow-sm">
                        <p class="text-sm font-medium text-gray-500">Chance of Rain</p>
                        <p class="text-3xl font-bold text-gray-800" id="rain"></p>
                    </div>
                </div>

            </div>
        </main>
    </div>

    <script>
        // Get references to all our HTML elements
        const checkButton = document.getElementById('checkButton');
        const loader = document.getElementById('loader');
        const results = document.getElementById('results');
        const errorBox = document.getElementById('errorBox');
        const errorMessage = document.getElementById('errorMessage');
        const manualInputBox = document.getElementById('manualInputBox');
        const locationInput = document.getElementById('locationInput');
        const searchButton = document.getElementById('searchButton');

        const locationEl = document.getElementById('location');
        const feelsLikeTempEl = document.getElementById('feelsLikeTemp');
        const warningMessageEl = document.getElementById('warningMessage');

        checkButton.addEventListener('click', () => {
            // Show loader, hide everything else
            checkButton.classList.add('hidden');
            loader.classList.remove('hidden');
            results.classList.add('hidden');
            errorBox.classList.add('hidden');
            manualInputBox.classList.add('hidden'); // Hide manual input
            
            // Try to get precise location
            navigator.geolocation.getCurrentPosition(handleGeoSuccess, handleGeoError, { enableHighAccuracy: true });
        });

        searchButton.addEventListener('click', () => {
            const cityName = locationInput.value;
            if (!cityName) {
                showError("Please enter a city or suburb name.");
                manualInputBox.classList.remove('hidden'); // Re-show the box
                return;
            }
            
            // Show loader, hide other UI
            loader.classList.remove('hidden');
            checkButton.classList.add('hidden');
            errorBox.classList.add('hidden');
            manualInputBox.classList.add('hidden');
            results.classList.add('hidden');

            geocodeAndFetch(cityName);
        });

        function handleGeoSuccess(position) {
            // 1. Success with precise location
            fetchDataAndDisplay(position.coords.latitude, position.coords.longitude);
        }

        function handleGeoError(error) {
            let message = "Unable to retrieve your location.";
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = "Please allow location access. Note: Geolocation requires a secure (HTTPS) connection. If you are in a preview, you may need to open this file directly in your browser.";
                    showError(message); // Show error and stop
                    break;
                case error.POSITION_UNAVAILABLE:
                case error.TIMEOUT:
                    // 2. Precise location failed, try IP fallback
                    fallbackGetLocation();
                    break;
                default:
                    showError(message); // Show generic error
            }
        }

        async function fallbackGetLocation() {
            try {
                // 3. Use IP-based location as a fallback
                const response = await fetch('https://ipapi.co/json/');
                if (!response.ok) {
                    throw new Error('IP location service failed.');
                }
                const data = await response.json();
                if (data.latitude && data.longitude) {
                    // 4. Got IP location, now fetch weather
                    fetchDataAndDisplay(data.latitude, data.longitude);
                } else {
                    throw new Error('Could not determine location from IP.');
                }
            } catch (error) {
                console.error("IP Fallback Error:", error);
                showError("Unable to retrieve your location. Precise location failed, and IP-based fallback also failed.");
            }
        }

        async function geocodeAndFetch(cityName) {
            try {
                // 1. Geocode city name to get lat/lon
                const geoUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cityName)}&count=1&format=json`;
                const response = await fetch(geoUrl);
                if (!response.ok) {
                    throw new Error("Location search service failed.");
                }
                const geoData = await response.json();
                if (!geoData.results || geoData.results.length === 0) {
                    throw new Error(`Could not find a location named "${cityName}".`);
                }

                const location = geoData.results[0];
                const lat = location.latitude;
                const lon = location.longitude;
                // Construct a clean name, e.g., "Sydney, New South Wales"
                const name = `${location.name}, ${location.admin1 || location.country}`;

                // 2. Fetch data, passing in the name we just found
                fetchDataAndDisplay(lat, lon, name);

            } catch (error) {
                console.error("Geocoding Error:", error);
                showError(error.message);
            }
        }

        async function fetchDataAndDisplay(lat, lon, manualCityName = null) {
            try {
                // 2. Fetch Weather Data
                const weatherData = await getWeatherData(lat, lon);
                
                // 3. Get City Name (if not already provided by manual search)
                const city = manualCityName ? manualCityName : await getCityName(lat, lon);

                // 4. Determine Warning Level
                const warning = getWarningData(weatherData.apparent_temperature);

                // 5. Display Results
                displayResults(weatherData, warning, city);

            } catch (error) {
                console.error("Error in weather fetching process:", error);
                showError(error.message || "Could not fetch weather data.");
            }
        }

        async function getWeatherData(lat, lon) {
            const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation_probability,wind_speed_10m&timezone=auto`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error("Weather data service is currently unavailable.");
            }
            
            const data = await response.json();

            if (!data.current) {
                throw new Error("Could not parse weather data.");
            }

            // Return a clean object
            return {
                temperature: Math.round(data.current.temperature_2m),
                humidity: data.current.relative_humidity_2m,
                apparent_temperature: Math.round(data.current.apparent_temperature),
                wind_speed: Math.round(data.current.wind_speed_10m),
                rain_probability: data.current.precipitation_probability
            };
        }

        async function getCityName(lat, lon) {
            try {
                // Using a free, privacy-friendly reverse geocoding API
                const apiUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10`;
                const response = await fetch(apiUrl, {
                    headers: { 'Accept-Language': 'en-US' }
                });
                if (!response.ok) return "Your Location";

                const data = await response.json();
                // Try to find suburb, city, or town
                const name = data.address.suburb || data.address.city || data.address.town || data.address.village;
                const state = data.address.state || "";
                
                if (name) {
                    return `${name}, ${state}`;
                } else {
                    return "Your Current Location";
                }
            } catch (error) {
                console.error("Error fetching city name:", error);
                return "Your Current Location"; // Fallback
            }
        }

        function getWarningData(feelsLikeTemp) {
            // Logic based on the provided image's "Feels Like" temperature ranges
            // Apparent Temperature thresholds in Celsius
            if (feelsLikeTemp >= 52) {
                return {
                    level: "Extreme Danger",
                    message: "Heat stroke is imminent. Stay cool.",
                    bgColor: "bg-red-800", // Dark Red
                    textColor: "text-white"
                };
            } else if (feelsLikeTemp >= 40) {
                return {
                    level: "Danger",
                    message: "Heat stroke is likely with prolonged exposure.",
                    bgColor: "bg-red-600", // Red
                    textColor: "text-white"
                };
            } else if (feelsLikeTemp >= 33) {
                return {
                    level: "Extreme Caution",
                    message: "Take breaks and hydrate frequently.",
                    bgColor: "bg-orange-500", // Orange
                    textColor: "text-white"
                };
            } else if (feelsLikeTemp >= 27) {
                return {
                    level: "Caution",
                    message: "Fatigue is possible with prolonged exposure.",
                    bgColor: "bg-yellow-400", // Yellow
                    textColor: "text-gray-800"
                };
            } else {
                return {
                    level: "Low Risk",
                    message: "Conditions are generally comfortable.",
                    bgColor: "bg-green-500", // Green
                    textColor: "text-white"
                };
            }
        }

        function displayResults(weather, warning, city) {
            // Set Location
            locationEl.innerText = city;

            // Set Main Warning Box
            feelsLikeTempEl.innerText = `${weather.apparent_temperature}°C`;
            warningLevelEl.innerText = warning.level;
            warningMessageEl.innerText = warning.message;

            // Apply dynamic colors
            warningBoxEl.className = `p-6 rounded-2xl shadow-md text-center ${warning.bgColor} ${warning.textColor}`;
            
            // Set Other Details
            actualTempEl.innerText = `${weather.temperature}°C`;
            humidityEl.innerText = `${weather.humidity}%`;
            windEl.innerText = `${weather.wind_speed} km/h`;
            rainEl.innerText = `${weather.rain_probability}%`;

            // Show results and hide loader
            loader.classList.add('hidden');
            results.classList.remove('hidden');
            checkButton.classList.remove('hidden'); // Show button again
        }

        function showError(message) {
            errorMessage.innerText = message;
            errorBox.classList.remove('hidden');
            manualInputBox.classList.remove('hidden'); // <-- Show manual input on error!
            loader.classList.add('hidden');
            checkButton.classList.remove('hidden'); // Show button again
        }
    </script>
</body>
</html>
